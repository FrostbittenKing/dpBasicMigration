

options {
	MULTI = true;
	OUTPUT_DIRECTORY="./java-gen/basicparser";
	VISITOR = true;
	NODE_DEFAULT_VOID = false;
	NODE_EXTENDS = "BaseNode";
/*	DEBUG_PARSER = true;
	DEBUG_LOOKAHEAD = true;
	DEBUG_TOKEN_MANAGER = true;*/
}

PARSER_BEGIN(BasicParser)
package basicparser;

import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.FileNotFoundException;
import java.io.OutputStream;
import basicparser.programflow.ProgramGraph;
import basicparser.SimpleNode;
import basicparser.programflow.GraphBuilder;

/** Simple brace matcher. */
public class BasicParser {

	/**
	 * Main entry point.
	 */
	public static void main(String args[]) throws ParseException, FileNotFoundException, IOException {
		InputStream instream = args.length == 0 ? System.in : new FileInputStream(args[0]);
		try {
		    SimpleNode root = pass1(instream);
			ProgramGraph graph = pass2(root);
			pass3(graph, System.out);
		}
		catch(Exception e) {
			System.out.println("Oops.");
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}

	public static SimpleNode pass1(InputStream instream) throws ParseException {
		BasicParser parser = new BasicParser(instream);
		ASTparseRoot r = parser.parseRoot();
		r.dump(">");
		return r;
	}

	public static ProgramGraph pass2(SimpleNode root) throws ParseException {
		GraphBuilder builder = new GraphBuilder();
		return builder.build(root);
	}

	public static void pass3(ProgramGraph graph, OutputStream out) throws IOException {
		System.out.println("<<<JAVA>>>");
		graph.translate(out);
	}
}

PARSER_END(BasicParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\r"
| "\f"
}


MORE : { <COMMENT: <INTEGER_LITERAL> ([" "])+ <REM>> : COMMENT_MODE }

/*
<LINE_START>
MORE :
{
	<([" "])+ <REM>> : COMMENT_MODE
}*/


<COMMENT_MODE>
SPECIAL_TOKEN :
{
	<END_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<COMMENT_MODE>
MORE:
{
	<~[]>
}



TOKEN : /* BASIC LANGUAGE RESERVED WORDS */
{
	<AND:	"and" | "AND">
|	<BRIGHT: "bright" | "BRIGHT">
|	<CLEAR:  "clear"  | "CLEAR">
|	<CLOAD:	 "cload" | "CLOAD">
|	<CLOADAST: "cload*" | "CLOAD*">
|	<CLOADA: "cloada" | "CLOADA">
|	<CLOADQEST: "cload?" | "CLOAD?">
|	<CONT: "cont" | "CONT">
|	<CURSORX: "cursorx" | "CURSORX">
|	<CURSORY: "cursory" | "CURSORY">
|	<CSAVE: "csave" | "CSAVE">
|	<CSAVEM: "csavem" | "CSAVEM">
|	<CSAVEL: "csavel" | "CSAVEL">
|	<CSAVES: "csaves" | "CSAVES">
|	<CSAVEAST: "csave*" | "CSAVE*">
|	<CSAVEX: "csavex" | "CSAVEX">
|	<DATA:	 "data" | "DATA">
|	<DELIM:	 "delim" | "DELIM">
|	<DIM: "dim" | "DIM">
|	<DISPLAY: "display" | "DISPLAY">
|	<END: "end" | "END">
| 	<FOR: "for" | "FOR">
|	<GOSUB: "gosub" | "GOSUB">
| 	<GOTO: "goto" | "GOTO">
|	<GR: "gr" | "GR">
| 	<IF: "if" | "IF">
|	<INIT: "init" | "INIT">
|	<INPUT: "input" | "INPUT">
|	<LET:	"let" | "LET">
|	<LINE:	"line" | "LINE">
|	<LIST:	"list" | "LIST">
|	<NEW:	"new" | "NEW">
| 	<NEXT: "next" | "NEXT">
|	<ON:   "on" | "ON">
|	<OR:   "or" | "OR">
|	<PAGE: "page" | "PAGE">
|	<POKE: "poke" | "POKE">
| 	<PRINT: "?" | "print" | "PRINT">
|	<READ:	"read" | "READ">
|	<REM:	"rem" | "REM">
|	<RESTORE:     "restore" | "RESTORE">
|	<RETURN: "return" | "RETURN">
|	<RUN:	 "run" | "RUN">
|	<SCREEN: "screen" | "SCREEN">
|	<SCROLL: "scroll" | "SCROLL">
|	<SOUND: "sound" | "SOUND">
| 	<STEP: "step" | "STEP">
|	<STOP: "stop" | "STOP">
|	<STORE: "store" | "STORE">
| 	<THEN: "then" | "THEN">
| 	<TO: "to" | "TO">
|	<TX: "tx" | "TX">
|   <DEF: "def" | "DEF">
}


TOKEN: /* BASIC MATHEMATICAL FUNCTIONS */
{
	<ABS:	"abs" | "ABS">
|	<ACTION:      "action" | "ACTION">
|	<ASC:	"asc" | "ASC">
|	<ATN:	"atn" | "ATN">
|	<CHR$:	"chr$" | "CHR$">
|	<COS:	"cos"  | "COS">
|	<EXP:	"exp"  | "EXP">
|	<FRE:	"fre"  | "FRE">
|	<INT:	"int"  | "INT">
|	<LEFT$:	"left$"	 | "LEFT$">
|	<LEN:	"len" | "LEN">
|	<LOG:	"log" | "LOG">
|	<MID$:	"mid$"	| "MID$">
|	<PEEK:	"peek"	| "PEEK">
|	<POS:	"pos"	| "POS">
|	<RIGHT$:    "right$"  | "RIGHT$">
|	<RND:	"rnd"	| "RND">
|	<SGN:	"sgn"	| "SGN">
|	<SIN:	"sin"	| "SIN">
|	<SPC:	"spc"	| "SPC">
|	<SQR:	"sqr"	| "SQR">
|	<STR:	"str$"	| "STR$">
|	<STICKX: "stickx" | "STICKX">
|	<STICKY: "sticky" | "STICKY">
|	<TAB:	 "tab"	  | "TAB">
|	<TAN:	 "tan"	  | "TAN">
|	<USR:	 "usr"	  | "USR">
|	<VAL:	 "val"	  | "VAL">
|	<KEY:	 "key"	  | "KEY">
}


TOKEN: /* LITERALS */
{
	<INTEGER_LITERAL: ["0"-"9"] ( ["0"-"9"] )*>
|	<FLOATING_POINT_LITERAL: (["0"-"9"])* "." (["0"-"9"])+>
|	<STRING_LITERAL: "\"" (~["\n","\r", "\""])* "\"">
/*|	<EXPRESSION: [ */
/*| <VAR: "*"+> */
}

TOKEN: /*IDENTIFIER*/
{
	<FUNCTION_NAME: "FN"<NUMERIC_IDENTIFIER>>
|	<NUMERIC_IDENTIFIER: <LETTER> (<PART_LETTER>)*>
|	<#LETTER: [ "A"-"Z","a"-"z"]>
|	<#PART_LETTER: [ "A"-"Z","a"-"z", "0"-"9" ]>
|	<IDENTIFIER: <NUMERIC_IDENTIFIER> <DOLLAR>>
}

/* SEPARATORS */
TOKEN :
{
	<LPAREN: "(">
|	<RPAREN: ")">
|	<SEMICOLON: ";">
|	<COMMA: (",")>
|	<DOLLAR: "$">

}

/* OPERATORS */
TOKEN :
{
	<ASSIGN: "=">
|	<GT: ">">
|	<LT: "<">
|	<COLON: ":">
|	<LE: "<=">
|	<GE: ">=">
|	<PLUS: "+">
|	<MINUS:	"-">
|	<STAR: "*">
|	<SLASH: "/">
|	<CIRCUMFLEX: "^">
}

/** Root production. */
ASTparseRoot parseRoot() #parseRoot:
{}
{
	(parseCommand() "\n" )* <EOF>
	{return jjtThis;}
}

void lineNumber() #LineNumber:
{
		Token t;
}
{
	t=<INTEGER_LITERAL> {jjtThis.lineNumber = Integer.parseInt(t.image);}
}

void parseCommand():
{}
{
	lineNumber() Statement() (":" Statement())*
/*(ifStatement() | gotoStatement() | forLoopStatement() | printStatement())*/
}


void Expression() #void :
{
}
{
	(LogicalOrExpression()) #Expression(!(jjtree.peekNode() instanceof ASTStringLiteral)) 
}

void LogicalOrExpression() #void :
{}
{
	(LogicalAndExpression() ( <OR> LogicalAndExpression() )*) #LogicalOr(>1)
}

void LogicalAndExpression() #void :
{}
{
	(ComparisonExpression() ( <AND> ComparisonExpression() )*) #LogicalAnd(>1)
}

void ComparisonExpression() #void  :
{}
{
	(RelationalExpression() ( ("=") RelationalExpression() )*) #ComparisonExp(>1)
}

void RelationalExpression() #void :
{
		Token t;
}
{
	(AdditiveExpression() ( (t="<" | t=">" | t="<=" | t=">=" | t="<>") {jjtThis.typeList.add(ASTRelationalExp.Type.fromIdentity(t.image));} AdditiveExpression() )*) #RelationalExp(>1)
}


void AdditiveExpression() #void :
{    
     Token t;
}
{
	(MultiplicativeExpression() ( /** WARNING SUPPRESSED, I HOPE I KNOW WHAT I'M DOING**/ LOOKAHEAD(1) (t="+" | t="-") {jjtThis.typeList.add(ASTAdd.Type.fromIdentity(t.image));} MultiplicativeExpression())*) #Add(>1)
}

void MultiplicativeExpression() #void  :
{
	Token t;
}
{
	(ExponentialExpression() ( ( t="*" | t="/") {jjtThis.typeList.add(ASTMult.Type.fromIdentity(t.image));} ExponentialExpression())*) #Mult(>1)
}

void ExponentialExpression() #void :
{}
{
	(UnaryExpression() ( "^" UnaryExpression())*) #Exp(>1)
}

void UnaryExpression()  #void :
{}
{
	(PrimaryExpression()
|	("-") UnaryExpression()
|	BasicFunctions()) #UnaryExpression(>1)
}

// ** SUBJECT TO CHANGE */
void PrimaryExpression()  #void :
{}
{
	(PrimaryPrefix()) #PrimaryExp(>1)
}

void PrimaryPrefix()  #void :
{}
{
	Literal()
|
	"(" Expression() ")"
|
	Variable()
}

void Variable() :
{}
{
	LOOKAHEAD(2)
	Array()
	|
	SimpleVariable()

}

void SimpleVariable() :
{}
{
	Name()
}

void Array()  :
{
}
{
	Name() <LPAREN> Expression()  ("," Expression())* <RPAREN>
}

ASTArrayDeclaration ArrayDeclaration() #ArrayDeclaration:
{
	Token t;
	ASTName name;
}
{
	name = Name() { jjtThis.name = (SimpleNode) name.jjtGetChild(0);}<LPAREN> t=<INTEGER_LITERAL> {jjtThis.parameters.push(t.image);} ("," t=<INTEGER_LITERAL> {jjtThis.parameters.push(t.image);})* <RPAREN>
	{return jjtThis;}
}

ASTName Name()  :
{
	Token t;
}
{
	t=<IDENTIFIER> {jjtThis.value = t.image;} #StringIdentifier
	{ return jjtThis; }
	|
	t=<NUMERIC_IDENTIFIER> {jjtThis.value = t.image;} #NumberIdentifier
	{ return jjtThis; }
}

void Literal() #Literal (!(jjtree.peekNode() instanceof ASTStringLiteral)):
{
	Token t;
}
{
	t=<INTEGER_LITERAL> {jjtThis.integerValue = Integer.parseInt(t.image);}
|
	t=<FLOATING_POINT_LITERAL> {jjtThis.doubleValue = Double.parseDouble(t.image);}
|
	t=<STRING_LITERAL> {jjtThis.stringValue = t.image;} #StringLiteral
}

void Statement() #Statement:
{}
{
	(brightStatement()
|	clearStatement()
|	contStatement()
|	cursorXStatement()
|	cursorYStatement()
|	defStatement()
|	delimStatement()
|	dimStatement()
|	displayStatement()
|	endStatement()
|	forLoopStatement()
|	gosubStatement()
|	gotoStatement()
|	grStatement()
|	ifStatement()
|	initStatement()
|	inputStatement()
|	letStatement()
|	lineStatement()
|	listStatement()
|	nextStatement()
|	newStatement()
|	onStatement()
|	pageStatement()
|	printStatement()
|	readStatement()
|	dataStatement()
|	restoreStatement()
|	returnStatement()
|	runStatement()
|	screenStatement()
|	scrollStatement()
|	soundStatement()
|	stopStatement()
|	storeStatement()
|	txStatement()
	)
}

void NumericExpressionParameter() :
{}
{
	<LPAREN> Expression() <RPAREN>
}

/*
void ParameterDeclaration(int count) :
{}
{
	<LPAREN> Parameter() ( "," Parameter())* <RPAREN>
}
*/

JAVACODE
void ParameterDeclaration(int count) {
     Token tok;
     tok = getToken(1);
     if (tok.kind != LPAREN)
     	throw new ParseException("Encountered, " + tok.image + ", but was expecting " + "\"(\"");
     getNextToken();
     if (count == 0) {
     	VariableLengthParameter();
     }
     else {
        Parameter();
     	for (int i=1 ; i < count ; i++) {
            tok = getToken(1);
	    if (tok.kind != COMMA)
	       throw new ParseException("Encountered, " + tok.image + ", but was expecting " + "\",\"");
	    getNextToken();
	    Parameter();
      	}
     }
     tok = getToken(1);
     if (tok.kind != RPAREN)
     	throw new ParseException("Encountered, " + tok.image + ", but was expecting " + "\")\"");
     getNextToken();
}


void VariableLengthParameter() :
{}
{
     Parameter() ("," Parameter())*
}

void Parameter() :
{}
{
	LOOKAHEAD(2) Expression() | SimpleVariable()
}

void BasicFunctions() :
{}
{
	Absolute()
|	Action()
|	Atan()
|	Ascii()
|	Cosine()
|	Char()
|	Exponent()
|	FreeBytes()
|	Left()
|	Length()
|	Logarithm()
|	Maxint()
|	Substring()
|	Position()
|	Random()
|	Right()
|	Signum()
|	Sine()
|	Space()
|	Squareroot()
|	StrToNum()
|	StickX()
|	StickY()
|	Tab()
|	Tangens()
|	UserProgram()
|	NumToStr()
|	KeyCharacter()
}

void Absolute() :
{}
{
	<ABS> ParameterDeclaration(1)
}

void Action() :
{}
{
	<ACTION> ParameterDeclaration(1)
}

void Ascii() :
{}
{
	<ASC> ParameterDeclaration(1)
}

void Atan() :
{}
{
	<ATN> ParameterDeclaration(1)
}

void Cosine() :
{}
{
	<COS> ParameterDeclaration(1)
}

void Char() :
{}
{
	<CHR$> ParameterDeclaration(1)
}

void Exponent() :
{}
{
	<EXP>	ParameterDeclaration(1)
}

void FreeBytes() :
{}
{
	<FRE>	ParameterDeclaration(1)
}

void Left() :
{}
{
	<LEFT$> ParameterDeclaration(2)
}

void Length() :
{}
{
	<LEN> ParameterDeclaration(1)
}

void Logarithm() :
{}
{
	<LOG>	ParameterDeclaration(1)
}


void Maxint() :
{}
{
	<INT> ParameterDeclaration(1)
}

void Substring() :
{}
{
	<MID$>	ParameterDeclaration(0)
}

void Position() :
{}
{
	<POS>	ParameterDeclaration(1)
}


void Random() :
{}
{
	<RND> ParameterDeclaration(1)
}

void Right() :
{}
{
	<RIGHT$> ParameterDeclaration(2)
}

void Signum() :
{}
{
	<SGN> ParameterDeclaration(1)
}

void Sine() :
{}
{
	<SIN>	ParameterDeclaration(1)
}

void Space() :
{}
{
	<SPC>	ParameterDeclaration(1)
}

void Squareroot() :
{}
{
	<SQR>	ParameterDeclaration(1)
}

void NumToStr() :
{}
{
	<STR>	ParameterDeclaration(1)
}

void StickX() :
{}
{
	<STICKX>	ParameterDeclaration(1)
}

void StickY() :
{}
{
	<STICKY>	ParameterDeclaration(1)
}

void Tab() :
{}
{
	<TAB>	ParameterDeclaration(1)
}

void Tangens() :
{}
{
	<TAN>	ParameterDeclaration(1)
}


/** DUNNO IF NEEDED */
void UserProgram() :
{}
{
	<USR>
}

void StrToNum() :
{}
{
	<VAL>	ParameterDeclaration(1)
}

void KeyCharacter() :
{}
{
	<KEY> ParameterDeclaration(1)
}

void brightStatement():
{
	Token t;
}
{
	<BRIGHT> t=<INTEGER_LITERAL> {jjtThis.brightness = Integer.parseInt(t.image);}
}

void clearStatement():
{
	Token t;
}
{
	<CLEAR>
	t=<INTEGER_LITERAL> {jjtThis.start = Integer.parseInt(t.image);} ","
	t=<INTEGER_LITERAL> {jjtThis.end = Integer.parseInt(t.image);}
}

void contStatement():
{}
{
	<CONT>
}

void cursorXStatement():
{
	Token t;
}
{
	<CURSORX> Expression()/* {jjtThis.x = Integer.parseInt(t.image);}*/
}

void cursorYStatement():
{
	Token t;
}
{
	<CURSORY> Expression() /*t=<INTEGER_LITERAL> {jjtThis.y = Integer.parseInt(t.image);}*/
}

void functionDefName():
{
	Token t;
}
{
	t=<FUNCTION_NAME> {jjtThis.name = t.image;}
}


void defStatement():
{}
{
	<DEF> functionDefName() (<LPAREN> Name() ("," Name())* <RPAREN>)? functionDefBody()
}

void functionDefBody():
{}
{
	"=" AdditiveExpression()
}

void delimStatement():
{
	Token t;
}
{
	<DELIM>
		t=<INTEGER_LITERAL> {jjtThis.foreground = Integer.parseInt(t.image);} ","
		t=<INTEGER_LITERAL> {jjtThis.background = Integer.parseInt(t.image);} ","
		t=<INTEGER_LITERAL> {jjtThis.type = Integer.parseInt(t.image);}
}

void dimStatement() #DimStatement:
{
ASTArrayDeclaration arrayDec;
}
{
	<DIM> arrayDec = ArrayDeclaration() { jjtThis.arrayDeclarations.push(arrayDec); }("," arrayDec = ArrayDeclaration() {jjtThis.arrayDeclarations.push(arrayDec);} )*
}



void displayStatement():
{}
{
	<DISPLAY>
}

void endStatement():
{}
{
	<END>
}

void gosubStatement() :
{}
{
	<GOSUB>	lineNumber()
}

void returnStatement():
{}
{
	<RETURN>
}

void grStatement() :
{
	Token t;
}
{
	<GR>
		t=<INTEGER_LITERAL> {jjtThis.foreground = Integer.parseInt(t.image);} ","
		t=<INTEGER_LITERAL> {jjtThis.background = Integer.parseInt(t.image);} ","
		t=<INTEGER_LITERAL> {jjtThis.type = Integer.parseInt(t.image);}
}



void gotoStatement() :
{
}
{
	<GOTO> lineNumber()
}

/* TODO: missing boolean expression literal */
void ifStatement() #If:
{
}
{
	<IF> Expression()

	(
		<THEN> 	( Statement() | lineNumber())
		       |
		gotoStatement()
	)
}
/*
void ifThenStatement():
{}
{
	<THEN> (Statement())
}

void ifGotoStatement():
{}
{
	gotoStatement()
}
*/
void initStatement():
{
	Token t;
}
{
	<INIT>	Expression() //{jjtThis.value = Integer.parseInt(t.image);}
}

void inputStatement():
{}
{
	<INPUT> (<STRING_LITERAL> <SEMICOLON>)? Name() ( "," Name())*
}

void letStatement():
{}
{
	(<LET>)? Variable() <ASSIGN> Expression()
}

void lineStatement():
{
	Token t;
}
{
	<LINE>
	/*t=<INTEGER_LITERAL> {jjtThis.first = Integer.parseInt(t.image);}*/ Expression() ","
	/*t=<INTEGER_LITERAL> {jjtThis.last = Integer.parseInt(t.image);}*/ Expression()
}

void listStatement():
{}
{
	<LIST>	(
	LOOKAHEAD (2, lineNumber()) lineNumber())?
}

void newStatement():
{}
{
	<NEW>
}

void onStatement():
{}
{
	<ON> Expression() ( <GOTO> | <GOSUB>) lineNumber() ("," lineNumber())*
}

void pageStatement():
{}
{
	<PAGE>
}


void readStatement():
{}
{
	<READ> Variable() ( "," Variable())*
}
void dataStatement():
{}
{
	<DATA> /*(Literal() | Name()) ( "," (Literal() | Name()))**/ Expression() ("," Expression())*
}
void restoreStatement():
{}
{
	<RESTORE> (
	LOOKAHEAD(2) lineNumber())?
}
void runStatement():
{}
{
	<RUN>	(LOOKAHEAD(2) lineNumber())?
}

void screenStatement():
{}
{
	<SCREEN>
}
void scrollStatement():
{}
{
	<SCROLL>
}
void soundStatement():
{
	Token t;
}
{
	<SOUND> /*t=<INTEGER_LITERAL> {jjtThis.tone = Integer.parseInt(t.image);} */ Expression()
}
void stopStatement():
{}
{
	<STOP>
}
void storeStatement():
{}
{
	<STORE>
}
void txStatement():
{
	Token t;
}
{
	<TX>
	/*	t=<INTEGER_LITERAL> {jjtThis.foreground = Integer.parseInt(t.image);} */ Expression() ","
	/*	t=<INTEGER_LITERAL> {jjtThis.fontSize = Integer.parseInt(t.image);}*/ Expression() ","
	/*	t=<INTEGER_LITERAL> {jjtThis.setBlinking(Integer.parseInt(t.image));}*/ Expression()
}

/* TODO: missing variable literal, embedded commands because it expects at least one command for some reason */
void forLoopStatement() :
{
	Token t;
}
{
	<FOR> Variable() <ASSIGN>
		Expression()
	<TO>
		Expression()
	(<STEP> Expression())?
}

void nextStatement() :
{}
{
	<NEXT> Variable()
}

/* TODO: missing text literal */
void printStatement() :
{}
{
	<PRINT> printText() ("," printText())*
}

void printText() :
{}
{ (
	LOOKAHEAD(2)
	Expression() (<SEMICOLON>)?)*
}
